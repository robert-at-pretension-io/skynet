["{\"name\": \"load_functions_from_file\", \"file_location\": \"./functions/get_functions.py\", \"source_code\": \"def load_functions_from_file(file_path) -> [FunctionInfo]:\\n    try:\\n        with open(file_path, 'r') as file:\\n            file_contents = file.read()\\n            logger.info(f'file size: {len(file_contents)}')\\n            try:\\n                tree = ast.parse(file_contents, type_comments=True)\\n                logger.info(f'tree size: {len(tree.body)}')\\n                functions = []\\n                imported_modules = {}\\n                for node in ast.walk(tree):\\n                    if isinstance(node, ast.Import):\\n                        for name in node.names:\\n                            imported_modules[name.name] = importlib.import_module(name.name)\\n                    elif isinstance(node, ast.ImportFrom):\\n                        module = importlib.import_module(node.module)\\n                        for name in node.names:\\n                            imported_modules[name.name] = getattr(module, name.name)\\n                    if isinstance(node, ast.FunctionDef):\\n                        logger.info(f'Looking at function: {node.name}')\\n                        func_name = node.name\\n                        func_code = compile(ast.Module(body=[node], type_ignores=[]), filename='<ast>', mode='exec')\\n                        temp_namespace = {**imported_modules}\\n                        exec(func_code, temp_namespace)\\n                        func = temp_namespace[func_name]\\n                        sig = inspect.signature(func)\\n                        arg_types = {param_name: param.annotation for param_name, param in sig.parameters.items()}\\n                        source_code = ast.unparse(node)\\n                        function_info = FunctionInfo(func_name, file_path, source_code, '')\\n                        functions.append(function_info)\\n                return functions\\n            except SyntaxError as e:\\n                logger.error(f'Syntax error in {file_path}: {e}')\\n                return []\\n            except Exception as e:\\n                logger.error(f'Error loading functions from {file_path}: {e}')\\n                return []\\n    except FileNotFoundError:\\n        logger.error(f'The file {file_path} was not found.')\\n        return []\\n    except IOError:\\n        logger.error(f'Error reading the file {file_path}.')\\n        return []\", \"description\": \"This function loads Python function definitions from a given file path. It reads the file, analyses its contents, and returns a list of information about each function, including the function name, source code, and argument types. If it encounters errors such as syntax errors or file-related issues, it logs an error message and returns an empty list.\"}", "{\"name\": \"list_functions\", \"file_location\": \"./functions/get_functions.py\", \"source_code\": \"def list_functions(functions):\\n    logger.info('Available functions:')\\n    for func_name, func_info in functions.items():\\n        arg_types = func_info['arg_types']\\n        logger.info(f'Function: {func_name}, Argument Types: {arg_types}')\", \"description\": \"The 'list_functions' function logs the available functions and their argument types from the input 'functions' dictionary. It outputs these details as informational log messages.\"}", "{\"name\": \"get_argument_values\", \"file_location\": \"./functions/get_functions.py\", \"source_code\": \"def get_argument_values(arg_types):\\n    args = []\\n    for arg_name, arg_type in arg_types.items():\\n        while True:\\n            user_input = input(f'Enter value for {arg_name} ({arg_type}): ')\\n            try:\\n                if arg_type == int:\\n                    converted_value = int(user_input)\\n                elif arg_type == float:\\n                    converted_value = float(user_input)\\n                elif arg_type == bool:\\n                    converted_value = user_input.lower() in ['true', '1', 'yes']\\n                elif arg_type == str:\\n                    converted_value = user_input\\n                else:\\n                    converted_value = eval(user_input)\\n                if not isinstance(converted_value, arg_type) and arg_type != inspect._empty:\\n                    raise TypeError(f'Incorrect type for {arg_name}, expected {arg_type}')\\n                break\\n            except ValueError as e:\\n                logger.error(f'Invalid input: {e}')\\n            except TypeError as e:\\n                logger.error(e)\\n            except Exception as e:\\n                logger.error(f'Error processing input: {e}')\\n        args.append(converted_value)\\n    return args\", \"description\": \"This function takes argument types and prompts the user to enter values for each argument. The input is then converted to the corresponding type and added to a list. If the input is invalid, errors are logged. The function returns the list of argument values.\"}", "{\"name\": \"get_links\", \"file_location\": \"./functions/web_browsing.py\", \"source_code\": \"def get_links(url):\\n    response = requests.get(url)\\n    soup = BeautifulSoup(response.content, 'html.parser')\\n    links = [a.get('href') for a in soup.find_all('a', href=True)]\\n    return links\", \"description\": \"The function takes a URL as input, sends a request to the URL, and then scrapes the HTML content to find and return a list of all the links (URLs) found on the page.\"}", "{\"name\": \"process_command\", \"file_location\": \"./functions/web_browsing.py\", \"source_code\": \"def process_command(command):\\n    tokens = command.split()\\n    if tokens[0] == 'get_links':\\n        try:\\n            links = get_links(tokens[1])\\n            return links\\n        except ValueError:\\n            return 'Error: Please provide valid numbers.'\\n    elif tokens[0] == 'exit':\\n        return None\\n    else:\\n        return 'Unknown command'\", \"description\": \"The function processes a given command. If the command is 'get_links', it calls the get_links function with the input provided after 'get_links'. If the command is 'exit', it returns None. If the command is unknown, it returns 'Unknown command'. If there is a value error during 'get_links', it returns 'Error: Please provide valid numbers'.\"}", "{\"name\": \"return_gpt_response\", \"file_location\": \"./functions/openai_call.py\", \"source_code\": \"def return_gpt_response(message_log=[], prompt='', model='', return_json_oject=False):\\n    if message_log == [] and prompt == '':\\n        raise ValueError('Both message_log and prompt cannot be empty when calling return_chat_response.')\\n    if model == '':\\n        model = os.environ['DEFAULT_GPT_MODEL']\\n    if prompt != '':\\n        message_log.append({'role': 'user', 'content': prompt})\\n    if return_json_oject:\\n        chat_completion = client.chat.completions.create(model=model, messages=message_log, response_format={'type': 'json_object'})\\n        try:\\n            return_value = json.loads(chat_completion.choices[0].message.content)\\n            return return_value\\n        except:\\n            raise ValueError('The response from the AI could not be converted to a json object.')\\n    else:\\n        chat_completion = client.chat.completions.create(model=model, messages=message_log)\\n        return chat_completion.choices[0].message.content\", \"description\": \"The function `return_gpt_response` takes in input variables `message_log`, `prompt`, `model`, and `return_json_object`. It checks for empty inputs and then processes user chat input using OpenAI's GPT model to generate a response. If `return_json_object` is set to `True`, it returns a JSON object of the response; otherwise, it returns the generated chat response. If model type is not provided, it uses the default GPT model from the environment variables.\"}", "{\"name\": \"read_file\", \"file_location\": \"./functions/file_system_primitives.py\", \"source_code\": \"def read_file(file_path):\\n    \\\"\\\"\\\"Reads and returns the content of a file.\\\"\\\"\\\"\\n    try:\\n        logger.info(f'Reading file {file_path}')\\n        with open(file_path, 'r') as file:\\n            return file.read()\\n    except FileNotFoundError:\\n        print(f'The file {file_path} was not found.')\\n    except IOError:\\n        print(f'Error reading the file {file_path}.')\", \"description\": \"The function \\\"read_file\\\" takes a file path as input and returns the content of the file. It logs an info message for the file being read, and then attempts to read and return the file's contents. If the file is not found, it prints a message stating the file was not found. If there is an error reading the file, it prints a message indicating an error occurred.\"}", "{\"name\": \"write_file\", \"file_location\": \"./functions/file_system_primitives.py\", \"source_code\": \"def write_file(file_path, content, mode='w'):\\n    \\\"\\\"\\\"Writes content to a file. By default, it overwrites the file.\\n    \\n    Args:\\n    - file_path: Path to the file.\\n    - content: Content to be written.\\n    - mode: Writing mode ('w' for overwrite, 'a' for append).\\n    \\\"\\\"\\\"\\n    try:\\n        logger.info(f'Writing to file {file_path}')\\n        with open(file_path, mode) as file:\\n            file.write(content)\\n    except IOError:\\n        print(f'Error writing to the file {file_path}.')\", \"description\": \"The function \\\"write_file\\\" takes three input variables - \\\"file_path\\\", \\\"content\\\", and \\\"mode\\\" (with a default value of 'w'). It writes the given content to the file specified by \\\"file_path\\\" in the specified mode (either overwrite or append). If the file writing operation encounters an error, an appropriate error message is displayed.\"}", "{\"name\": \"append_to_file\", \"file_location\": \"./functions/file_system_primitives.py\", \"source_code\": \"def append_to_file(file_path, content):\\n    \\\"\\\"\\\"Appends content to the end of a file.\\\"\\\"\\\"\\n    write_file(file_path, content, mode='a')\", \"description\": \"The function \\\"append_to_file\\\" appends content to the end of a file by calling the \\\"write_file\\\" function with the append mode.\"}", "{\"name\": \"delete_file\", \"file_location\": \"./functions/file_system_primitives.py\", \"source_code\": \"def delete_file(file_path):\\n    \\\"\\\"\\\"Deletes a file.\\\"\\\"\\\"\\n    try:\\n        logger.info(f'Deleting file {file_path}')\\n        os.remove(file_path)\\n    except FileNotFoundError:\\n        print(f'The file {file_path} does not exist.')\\n    except OSError:\\n        print(f'Error deleting the file {file_path}.')\", \"description\": \"The function \\\"delete_file\\\" deletes the specified file. It logs the file deletion, and if the file doesn't exist, it prints a message that the file does not exist. If there is any error during the file deletion, it prints an error message indicating an issue with the file deletion.\"}", "{\"name\": \"list_files_in_directory\", \"file_location\": \"./functions/file_system_primitives.py\", \"source_code\": \"def list_files_in_directory(directory=''):\\n    \\\"\\\"\\\"Lists all files in a given directory.\\n\\n    Args:\\n    - directory: The path to the directory.\\n\\n    Returns:\\n    - A list of file names in the directory.\\n    \\\"\\\"\\\"\\n    try:\\n        logger.info(f'Listing files in directory {directory}')\\n        return [file for file in os.listdir(directory) if os.path.isfile(os.path.join(directory, file))]\\n    except FileNotFoundError:\\n        print(f'Directory {directory} not found.')\\n        return []\\n    except OSError as e:\\n        print(f'Error accessing directory {directory}: {e}')\\n        return []\", \"description\": \"This function lists all files in a given directory path. If the directory path exists, it returns a list of file names within that directory. If the directory does not exist or an error occurs during access, it returns an empty list with a corresponding error message.\"}", "{\"name\": \"get_current_working_directory\", \"file_location\": \"./functions/file_system_primitives.py\", \"source_code\": \"def get_current_working_directory():\\n    \\\"\\\"\\\"Returns the current working directory.\\\"\\\"\\\"\\n    logger.info('Getting current working directory')\\n    return os.getcwd()\", \"description\": \"The \\\"get_current_working_directory\\\" function returns the path to the current working directory of the program. If the directory cannot be accessed or encountered during the process, the function logs an error and returns the failure message.\"}", "{\"name\": \"set_env_variables_with_defaults\", \"file_location\": \"./functions/file_system_primitives.py\", \"source_code\": \"def set_env_variables_with_defaults(env_vars_defaults):\\n    \\\"\\\"\\\"\\n    Sets environment variables to default values if they are not already set.\\n\\n    Args:\\n    - env_vars_defaults: A dictionary where keys are environment variable names \\n                         and values are the default values for these variables.\\n    \\\"\\\"\\\"\\n    for var, default in env_vars_defaults.items():\\n        if var not in os.environ:\\n            if default != 'error':\\n                logger.info(f'Setting environment variable {var} to default value {default}')\\n                os.environ[var] = default\\n            else:\\n                logger.error(f'Environment variable {var} not set. This is a required variable and no default value provided.')\\n                raise ValueError(f'Environment variable {var} not set. This is a required variable and no default value provided.')\", \"description\": \"This function sets environment variables to default values if they are not already set. It takes in a dictionary where keys are environment variable names and values are the default values for these variables. If the environment variable is not set, it is assigned the default value. If a required variable doesn't have a default value, it raises an error.\"}", "{\"name\": \"return_function_options\", \"file_location\": \"./functions/prompt_creation.py\", \"source_code\": \"def return_function_options(functions: [FunctionInfo]) -> str:\\n    function_options = ''\\n    for function in functions:\\n        function_options += f'{function.function_name} : {function.description}\\\\n'\\n    return function_options\", \"description\": \"This function takes a list of FunctionInfo objects as input and returns a string containing the name and description of each function in the list. Each function's name and description is concatenated together into the output string, separated by a colon and a new line.\"}", "{\"name\": \"create_function\", \"file_location\": \"./functions/prompt_creation.py\", \"source_code\": \"def create_function(function_objective: str, language: str) -> object:\\n    prompt = f'Create a function that accomplishes the following: {function_objective}\\\\n\\\\n    Using the {language} programming language.\\\\n\\\\n    it should return a json object with the following properties:\\\\n\\\\n    required_libraries: a list of strings\\\\n\\\\n    source_code: a string\\\\n\\\\n    The source code should ONLY be the function definition, including the function definition and the function body.\\\\n    '\\n    try:\\n        return return_gpt_response(prompt=prompt, return_json_oject=True)\\n    except Exception as e:\\n        raise ValueError(f'Error creating function: {e}')\", \"description\": \"The `create_function` function generates a prompt for creating a function with a specified objective and programming language. It then uses the GPT (Generative Pre-trained Transformer) model to generate the source code for the function as a JSON object, including required libraries and the source code. If an error occurs during the function creation process, it raises an exception with a corresponding error message.\"}", "{\"name\": \"create_step_list\", \"file_location\": \"./functions/prompt_creation.py\", \"source_code\": \"def create_step_list(goal: str) -> object:\\n    prompt = f'Create a step list that accomplishes the following: {goal}\\\\n\\\\n    The json object returned should have the following properties:\\\\n    step_list: a list of strings describing the steps to accomplish the goal\\\\n    verification: a string describing how to verify that the goal has been accomplished\\\\n    '\\n    try:\\n        return return_gpt_response(prompt=prompt, return_json_oject=True)\\n    except Exception as e:\\n        raise ValueError(f'Error creating step list: {e}')\", \"description\": \"The function \\\"create_step_list\\\" takes in a goal and generates a step list in the form of a JSON object. It prompts the user with the goal and returns a structured step list as a JSON object containing a list of strings outlining the steps needed to achieve the goal, as well as a string describing how to verify the completion of the goal. If any errors occur during the process, it raises a value error along with the error message.\"}", "{\"name\": \"describe_function\", \"file_location\": \"./functions/prompt_creation.py\", \"source_code\": \"def describe_function(function_string):\\n    \\\"\\\"\\\"Returns a description of the function.\\\"\\\"\\\"\\n    prompt = f'Describe the function, using the input variables. Make the description succinct though covering its entire functionality using plain english: \\\\n    \\\\n    {function_string}\\\\n    \\\\n    Description:'\\n    try:\\n        logger.info('Describing function')\\n        return return_gpt_response(prompt=prompt)\\n    except Exception as e:\\n        logger.error(f'Error describing function: {e}')\\n        raise ValueError('Error describing function.')\", \"description\": \"The \\\"describe_function\\\" function takes a function string as input and returns a description of the function by using GPT-3 natural language processing. It creates a prompt matching the format of a succinct description for a function, then uses GPT-3 to generate the description based on the provided function string. If there are any errors during the process, it raises a ValueError.\"}", "{\"name\": \"required_fields\", \"file_location\": \"./functions/prompt_creation.py\", \"source_code\": \"def required_fields(fields: [str], json_object: object) -> bool:\\n    \\\"\\\"\\\"Returns true if the required fields are present in the json object\\\"\\\"\\\"\\n    for field in fields:\\n        if field not in json_object:\\n            return False\\n    return True\", \"description\": \"The function checks if all the required fields specified in the list are present in the given JSON object. If all the required fields are present, it returns `True`; otherwise, it returns `False`.\"}", "{\"name\": \"initialize_twitter_api\", \"file_location\": \"./functions/generated_functions.py\", \"source_code\": \"def initialize_twitter_api(api_key, api_secret_key, access_token, access_token_secret):\\n    auth = tweepy.OAuthHandler(api_key, api_secret_key)\\n    auth.set_access_token(access_token, access_token_secret)\\n    api = tweepy.API(auth)\\n    return api\", \"description\": \"This function takes in the Twitter API key, API secret key, access token, and access token secret as input variables. It then uses these variables to authenticate and initialize the Twitter API, and returns the initialized API for use in accessing Twitter data and functionality.\"}"]